priority -50

global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False
endglobal

##################
# EQUATION STUFF #
##################

snippet eq "Equation" b
\begin{equation}
	${0:${VISUAL}}
\end{equation}
endsnippet

snippet eql "Labeled equation environment" b
\begin{equation}
	\label{eq:${1}}
	${0:${VISUAL}}
\end{equation}
endsnippet

snippet eqnn "Equation without a number" b
\begin{equation*}
	${0:${VISUAL}}
\end{equation*}
endsnippet

snippet al "Align" b
\begin{align}
	${0:${VISUAL}}
\end{align}
endsnippet

snippet alnn "Align without a number" b
\begin{align*}
	${0:${VISUAL}}
\end{align*}
endsnippet

snippet algn "align" w
&${1:=}`!p
options = {	'a':'\\approx',
			'l':'\\le',
			'g':'\\ge',
			'p':'\\propto',
			'n':'\\neq'}
if t[1] in options.keys():
	t[1] = options[t[1]]` $0
endsnippet

snippet eqa "Equation array" b
\begin{eqnarray}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray}
endsnippet

snippet eqann "Equation array without a number" b
\begin{eqnarray*}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray*}
endsnippet

snippet case "amsmath cases" w
\begin{cases}
	${1:${VISUAL}}$0
\end{cases}
endsnippet

snippet rcase "right cases with amsmath" w
\begin{equation*}
\begin{rcases}
	${1:${VISUAL}}
\end{rcases}
${2:\text{${3:text}}}$0
\end{equation*}
endsnippet

snippet ubr "underbrace" w
\underbrace{${1:${VISUAL}}}_{\math${2:c}lap{${3}}}$0
endsnippet

snippet obr "overbrace" w
\overbrace{${1:${VISUAL}}}_{\math${2:c}lap{${3}}}$0
endsnippet

snippet oset "overset" w
\overset{${1:${VISUAL}}}{${2:=}}$0
endsnippet

snippet canc "cancel" w
\cancel{${1:${VISUAL}}}$0
endsnippet

snippet canct "cancel to" w
\cancelto{${2:0}}{${1:${VISUAL}}}$0
endsnippet

snippet qd "quad spacing" w
\quad $0
endsnippet

##############
# MATH STUFF #
##############

snippet lr "left right" w
\left${1} ${0:${VISUAL}} \right${1}
endsnippet

snippet lr( "left( right)" w
\left( ${1:${VISUAL}} \right)$0
endsnippet

snippet lr| "left| right|" w
\left| ${1:${VISUAL}} \right|$0
endsnippet

snippet lr{ "left\{ right\}" w
\left\{ ${1:${VISUAL}} \right\}$0
endsnippet

snippet lr[ "left[ right]" w
\left[ ${1:${VISUAL}} \right]$0
endsnippet

snippet lra "langle rangle" w
\langle ${1:${VISUAL}} \rangle$0
endsnippet

snippet prto "proportional to" w
\propto $0
endsnippet

snippet aprx "approximately" w
\approx $0
endsnippet

snippet eqv "equivalent" w
\equiv $0
endsnippet

snippet sim "similar" w
\sim $0
endsnippet

snippet lim "limit" w
\lim_{${1:n}\to${2:\infty}} $0
endsnippet

snippet ddt "time derivative" w
\frac{d ${1:${VISUAL}}}{dt}$0
endsnippet

snippet dot "dot derivative" w
\dot{${1:${VISUAL}}}$0
endsnippet

snippet '([2-3])dot' "multiple dot derivatives" wr
\\`!p snip.rv = 'd'*int(match.group(1))`ot{${1:${VISUAL}}}$0
endsnippet

snippet dint "definite integral" w
\int_{${1:-\infty}}^{${2:\infty}} ${4} ${3:dx}$0
endsnippet

snippet int "indefinite integral" w
\int ${2} ${1:dx}$0
endsnippet

snippet '([2-3])int' "multiple indefinite integral" wr
\\`!p snip.rv = 'i'*int(match.group(1))`nt ${2} ${1:dx}$0
endsnippet

snippet oint "closed integral" w
\oint_{${1:C}} ${3} ${2:dx}$0
endsnippet

snippet sum "summation with range" w
\sum_{${1:n=1}}^{${2:\infty}} $0
endsnippet

snippet prod "product with range" w
\prod_{${1:n=1}}^{${2:\infty}} $0
endsnippet

snippet eval "evaluate from .. to .." w
\eval{${3:${VISUAL}}}_{${1:-\infty}}^{${2:\infty}}$0
endsnippet

context "math()"
snippet sr "x squared" iA
^2$0
endsnippet

context "math()"
snippet cb "x cubed" iA
^3$0
endsnippet

context "math()"
snippet inv "inverse" iA
^{-1}$0
endsnippet

context "math()"
snippet '(\w+)~' "tilde character" rA
\tilde{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet '(\w+)-' "bar character" rA
\bar{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet exp "exponential" wA
e^{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet norm "norm" wA
\|${1:${VISUAL}}\|$0
endsnippet

context "math()"
snippet sq "square root" wA
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet oop "circle operator" w
\o${1:t}${1/(t)$|(p)$|(d)$/(?1:imes)(?2:lus)(?3:ot)/} $0
endsnippet

snippet mk "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet dm "Math" wA
\[
$1
.\] $0
endsnippet

context "math()"
snippet // "fraction" iA
\frac{${1:${VISUAL}}}{${2}}$0
endsnippet

context "math()"
snippet __ "subscript" iA
_{${1}}$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

context "math()"
snippet td "to the .. power" iA
^{${1}}$0
endsnippet

context "math()"
snippet dg "hermition" i
^\dag$0
endsnippet

context "math()"
snippet ooo "infinity" iA
\infty$0
endsnippet

context "math()"
snippet xx "times" iA
\times $0
endsnippet

context "math()"
snippet ** "dot product" iA
\cdot $0
endsnippet

context "math()"
snippet <= "less than or equal" iA
\leq $0
endsnippet

context "math()"
snippet >= "greater than or equal" iA
\geq $0
endsnippet

context "math()"
snippet << "much smaller than" iA
\ll $0
endsnippet

context "math()"
snippet >> "much greater than" iA
\gg $0
endsnippet

context "math()"
snippet => "implies..." iA
\implies $0
endsnippet

context "math()"
snippet <- "results from..." iA
\leftarrow $0
endsnippet

context "math()"
snippet -> "results in..." iA
\rightarrow $0
endsnippet

context "math()"
snippet iff "if and only if" wA
\iff $0
endsnippet

################
# CUSTOM STUFF #
################

snippet '(\w)arw' "directional arrow" wr
`!p
dir = match.group(1)
if dir == "u":
	snip.rv = "\\uparrow"
elif dir == "d":
	snip.rv = "\\downarrow"
elif dir == "r":
	snip.rv = "\\rightarrow"
elif dir == "l":
	snip.rv = "\\leftarrow"
`$0
endsnippet

priority 999
# by Gilles Castel
context "math()"
snippet '((\d+)?(\\)?([A-Za-z]*)((\^|_)((\{\d+\})|(\d)))?)/' "symbol frac" wrA
\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

# Examples:
# (...)/ ->  \frac{...}{|}
# (Matching from the beginning of the line because some annoying bugs...)
priority 1000
# by Gilles Castel
context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

context "math()"
snippet 'oint(cw|ccw)' "closed integral with direction" wr
`!p
d = match.group(1)
if d == 'cw':
	snip.rv = r'\varointclockwise'
else:
	snip.rv = r'\ointctrclockwise'
`_{${1:C}} ${3} ${2:dx}$0
endsnippet

context "math()"
snippet 'sum([a-z])' "summation with no range" wr
\sum_`!p snip.rv = match.group(1)` $0
endsnippet

context "math()"
snippet 'prod([a-z])' "product with no range" wr
\prod_`!p snip.rv = match.group(1)` $0
endsnippet

#priority -1000
#snippet '(\w|\d)' "index" ir
#_`!p snip.rv = match.group(1)`$0
#endsnippet

# vim:ft=snippets:
