priority -50

global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(i for i in reversed(synstackids) if i in texIgnoreMathZoneIds or i in texMathZoneIds)
		return first != ignore
	except StopIteration:
		return False
endglobal

##################
# EQUATION STUFF #
##################

snippet eq "Equation" b
\begin{equation}
	${0:${VISUAL}}
\end{equation}
endsnippet

snippet eql "Labeled equation environment" b
\begin{equation}
	\label{eq:${1}}
	${0:${VISUAL}}
\end{equation}
endsnippet

snippet eqnn "Equation without a number" b
\begin{equation*}
	${0:${VISUAL}}
\end{equation*}
endsnippet

snippet al "Align" b
\begin{align}
	${0:${VISUAL}}
\end{align}
endsnippet

snippet alnn "Align without a number" b
\begin{align*}
	${0:${VISUAL}}
\end{align*}
endsnippet

snippet eqa "Equation array" b
\begin{eqnarray}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray}
endsnippet

snippet eqann "Equation array without a number" b
\begin{eqnarray*}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray*}
endsnippet

snippet case "amsmath cases" w
\begin{cases}
	${1:${VISUAL}}$0
\end{cases}
endsnippet

snippet rcase "right cases with amsmath" w
\begin{equation*}
\begin{rcases}
	${1:${VISUAL}}
\end{rcases}
${2:\text{${3:text}}}$0
\end{equation*}
endsnippet

snippet txt "text environment" wA
\text${1:b}${1/(b)$|(i)$/(?1:f)(?2:t)/}{${2}}$0
endsnippet

snippet <- "results from..." iA
$\leftarrow$ $0
endsnippet 
snippet -> "results in..." iA
$\rightarrow$ $0
endsnippet

################
# FORMAT STUFF #
################

context "math()"
snippet == "equals" iA
&= $1 \\\\
endsnippet

context "math()"
snippet algn "align" w
&${1:=}`!p
options = {	'a':'\\approx',
			'l':'\\le',
			'g':'\\ge',
			'p':'\\propto',
			'n':'\\neq'}
if t[1] in options.keys():
	t[1] = options[t[1]]` ${2} \\\\
endsnippet

context "math()"
snippet ubr "underbrace" w
\underbrace{${1:${VISUAL}}}_{\math${2:c}lap{${3}}}$0
endsnippet

context "math()"
snippet obr "overbrace" w
\overbrace{${1:${VISUAL}}}_{\math${2:c}lap{${3}}}$0
endsnippet

context "math()"
snippet oset "overset" w
\overset{${1:${VISUAL}}}{${2:=}}$0
endsnippet

context "math()"
snippet canc "cancel" w
\cancel{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet canct "cancel to" w
\cancelto{${2:0}}{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet qd "quad spacing" w
\quad $0
endsnippet

##############
# MATH STUFF #
##############

context "math()"
snippet lr "left right" i
\left${1} ${0:${VISUAL}} \right${1}
endsnippet

context "math()"
snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right)$0
endsnippet

context "math()"
snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right|$0
endsnippet

context "math()"
snippet lr{ "left\{ right\}" i
\left\{ ${1:${VISUAL}} \right\}$0
endsnippet

context "math()"
snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right]$0
endsnippet

context "math()"
snippet lra "langle rangle" i
\langle ${1:${VISUAL}} \rangle$0
endsnippet

context "math()"
snippet prto "proportional to" wA
\propto $0
endsnippet

context "math()"
snippet aprx "approximately" wA
\approx $0
endsnippet

context "math()"
snippet eqv "equivalent" wA
\equiv $0
endsnippet

context "math()"
snippet sim "similar" wA
\sim $0
endsnippet

context "math()"
snippet lim "limit" wA
\lim_{${1:n}\to${2:\infty}} $0
endsnippet

context "math()"
snippet ddt "time derivative" wA
\frac{d ${1:${VISUAL}}}{dt}$0
endsnippet

context "math()"
snippet dot "dot derivative" wA
\dot{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet '([2-3])dot' "multiple dot derivatives" wrA
\\`!p snip.rv = 'd'*int(match.group(1))`ot{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet dint "definite integral" wA
\int_{${1:-\infty}}^{${2:\infty}} ${4} ${3:dx}$0
endsnippet

context "math()"
snippet int "indefinite integral" wA
\int ${2} ${1:dx}$0
endsnippet

context "math()"
snippet '([2-3])int' "multiple indefinite integral" wrA
\\`!p snip.rv = 'i'*int(match.group(1))`nt ${2} ${1:dx}$0
endsnippet

context "math()"
snippet oint "closed integral" wA
\oint_{${1:C}} ${3} ${2:dx}$0
endsnippet

context "math()"
snippet 'oint(cw|ccw)' "closed integral with direction" wrA
`!p
d = match.group(1)
if d == 'cw':
	snip.rv = r'\varointclockwise'
else:
	snip.rv = r'\ointctrclockwise'
`_{${1:C}} ${3} ${2:dx}$0
endsnippet

context "math()"
snippet sum "summation with range" wA
\sum_{${1:n=1}}^{${2:\infty}} $0
endsnippet

context "math()"
snippet 'sum([a-z])' "summation with no range" wrA
\sum_`!p snip.rv = match.group(1)` $0
endsnippet

context "math()"
snippet prod "product with range" wA
\prod_{${1:n=1}}^{${2:\infty}} $0
endsnippet

context "math()"
snippet 'prod([a-z])' "product with no range" wrA
\prod_`!p snip.rv = match.group(1)` $0 endsnippet

context "math()""
snippet eval "evaluate from .. to .." wA
\eval{${3:${VISUAL}}}_{${1:-\infty}}^{${2:\infty}}$0
endsnippet

context "math()"
snippet sr "x squared" iA
^2$0
endsnippet

context "math()"
snippet cb "x cubed" iA
^3$0
endsnippet

context "math()"
snippet inv "inverse" iA
^{-1}$0
endsnippet

context "math()"
snippet '(\w+)~' "tilde character" rA
\tilde{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet '(\w+)-' "bar character" rA
\bar{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet exp "exponential" wA
e^{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet norm "norm" wA
\|${1:${VISUAL}}\|$0
endsnippet

context "math()"
snippet sq "square root" wA
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet oop "circle operator" iA
\o${1:t}${1/(t)$|(p)$|(d)$/(?1:imes)(?2:lus)(?3:ot)/} $0
endsnippet

snippet mk "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet dm "Math" wA
\[
$1
.\] $0
endsnippet

context "math()"
snippet __ "subscript" iA
_{${1}}$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

context "math()"
snippet td "to the .. power" iA
^{${1}}$0
endsnippet

context "math()"
snippet log "logarithm" wA
\log$0
endsnippet

context "math()"
snippet dg "hermition" iA
^\dag$0
endsnippet

context "math()"
snippet ooo "infinity" iA
\infty$0
endsnippet

context "math()"
snippet xx "times" iA
\times $0
endsnippet

context "math()"
snippet ** "dot product" iA
\cdot $0
endsnippet

context "math()"
snippet <= "less than or equal" iA
\leq $0
endsnippet

context "math()"
snippet >= "greater than or equal" iA
\geq $0
endsnippet

context "math()"
snippet << "much smaller than" iA
\ll $0
endsnippet

context "math()"
snippet >> "much greater than" iA
\gg $0
endsnippet

context "math()"
snippet => "implies..." iA
\implies $0
endsnippet

context "math()"
snippet iff "if and only if" wA
\iff $0
endsnippet

context "math()"
snippet '(\w)arw' "directional arrow" wrA
`!p
dir = match.group(1)
if dir == "u":
	snip.rv = "\\uparrow"
elif dir == "d":
	snip.rv = "\\downarrow"
elif dir == "r":
	snip.rv = "\\rightarrow"
elif dir == "l":
	snip.rv = "\\leftarrow"
`$0
endsnippet

####################
# GREEK CHARACTERS #
####################

context "math()"
snippet \G "Gamma" iA
\Gamma
endsnippet

context "math()"
snippet \D "Delta" iA
\Delta
endsnippet

context "math()"
snippet \L "Lambda" iA
\Lambda
endsnippet

context "math()"
snippet \F "Phi" iA
\Phi
endsnippet

context "math()"
snippet \P "Pi" iA
\Pi
endsnippet

context "math()"
snippet \C "Psi" iA
\Psi
endsnippet

context "math()"
snippet \S "Sigma" iA
\Sigma
endsnippet

context "math()"
snippet \U "Theta" iA
\Theta
endsnippet

context "math()"
snippet \Y "Upsilon" iA
\Upsilon
endsnippet

context "math()"
snippet \J "Xi" iA
\Xi
endsnippet

context "math()"
snippet \V "Omega" iA
\Omega
endsnippet

context "math()"
snippet \a "alpha" iA
\alpha
endsnippet

context "math()"
snippet \b "beta" iA
\beta
endsnippet

context "math()"
snippet \g "gamma" iA
\gamma
endsnippet

context "math()"
snippet \d "delta" iA
\delta
endsnippet

context "math()"
snippet \e "epsilon" iA
\epsilon
endsnippet

context "math()"
snippet \z "zeta" iA
\zeta
endsnippet

context "math()"
snippet \h "eta" iA
\eta
endsnippet

context "math()"
snippet \u "theta" iA
\theta
endsnippet

context "math()"
snippet \i "iota" iA
\iota
endsnippet

context "math()"
snippet \k "kappa" iA
\kappa
endsnippet

context "math()"
snippet \l "lambda" iA
\lambda
endsnippet

context "math()"
snippet \m "mu" iA
\mu
endsnippet

context "math()"
snippet \n "nu" iA
\nu
endsnippet

context "math()"
snippet \j "xi" iA
\xi
endsnippet

context "math()"
snippet \p "pi" iA
\pi
endsnippet

context "math()"
snippet \r "rho" iA
\rho
endsnippet

context "math()"
snippet \s "sigma" iA
\sigma
endsnippet

context "math()"
snippet \t "tau" iA
\tau
endsnippet

context "math()"
snippet \y "upsilon" iA
\upsilon
endsnippet

context "math()"
snippet \f "phi" iA
\phi
endsnippet

context "math()"
snippet \x "chi" iA
\chi
endsnippet

context "math()"
snippet \c "psi" iA
\psi
endsnippet

context "math()"
snippet \v "omega" iA
\omega
endsnippet

priority -25
context "math()"
snippet \\dg "digamma" iA
\digamma
endsnippet

context "math()"
snippet \\ve "varepsilon" iA
\varepsilon
endsnippet

context "math()"
snippet \\vf "varphi" iA
\varphi
endsnippet

context "math()"
snippet \\vp "varpi" iA
\varpi
endsnippet

context "math()"
snippet \\vr "varrho" iA
\varrho
endsnippet

context "math()"
snippet \\vs "varsigma" iA
\varsigma
endsnippet

context "math()"
snippet \\vu "vartheta" iA
\vartheta
endsnippet

#############
# FRACTIONs #
#############

priority 100
context "math()"
snippet // "Fraction" iA
\frac{$1}{$2}$0
endsnippet

# by Gilles Castel
context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

# Examples:
# (...)/ ->  \frac{...}{|}
# (Matching from the beginning of the line because some annoying bugs...)
priority 1000
# by Gilles Castel
context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

###################
# PHYSICS PACKAGE #
###################

priority 0
context "math()"
snippet dv "Derivative" wA
\dv{${1}}{${2}}
endsnippet

priority 50
context "math()"
snippet pdv "Partial Derivative" wA
\pdv{${1}}{${2}}
endsnippet

context "math()"
snippet '((\d+)?(\\)?([A-Za-z]*)((\^|_)((\{\d+\})|(\d)))?)vec' "vector with arrow" rA
\va{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet '((\d+)?(\\)?([A-Za-z]*)((\^|_)((\{\d+\})|(\d)))?)unt' "unit vector" rA
\vu{`!p snip.rv = match.group(1)`}$0
endsnippet

context "math()"
snippet "\|(.*?)\>" "ket" riA
\ket{`!p snip.rv = match.group(1).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

context "math()"
snippet "(.*)\\bra{(.*?)}([^\|]*?)\>" "braket" riA
`!p snip.rv = match.group(1)`\braket{`!p snip.rv = match.group(2)`}{`!p snip.rv = match.group(3).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

context "math()"
snippet comm "commutator" wA
\comm{${1}}{${2}}$0
endsnippet

context "math()"
snippet expv "expectation value" wA
\expval{${1:x}}$0
endsnippet

context "math()"
snippet expvw "expectation value wrt..." wA
\expval{${1:x}}{${2:\Psi}}$0
endsnippet

context "math()"
snippet grad "gradient" wA
\grad
endsnippet

context "math()"
snippet div "divergence" wA
\divergence
endsnippet

context "math()"
snippet curl "curl" wA
\curl
endsnippet

context "math()"
snippet lapl "laplacian" wA
\laplacian
endsnippet

################
# CUSTOM STUFF #
################

priority 999
context "math()"
snippet 'dv(\d|n)' "nth derivative" wrA
\dv[`!p snip.rv = match.group(1)`]{${1}}{${2}}$0
endsnippet

priority 1000
context "math()"
snippet 'pdv(\d|n)' "nth partial derivative" wrA
\pdv[`!p snip.rv = match.group(1)`]{${1}}{${2}}$0
endsnippet

# vim:ft=snippets:
